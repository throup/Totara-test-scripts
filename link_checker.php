<?php

/**
 * Automated moodle site link checker
 *
 * Spiders the internal links on a Totara/Moodle and checks for
 * database, PHP or page errors (like 404s)
 *
 * WARNING: spidering a site can lead to site configuration changes in
 * cases where actions can be completed just by following links, rather
 * than via a POST request. In Moodle, examples include enabling/disabling
 * authentication modules, moving blocks and showing/hiding courses.
 * DON'T RUN THIS SCRIPT ON A PRODUCTION SITE!
 *
 * To add more checks, add code to the $link_checker->look_for_errors()
 * method.
 *
 * Dependencies:
 * cURL for spidering site <http://www.php.net/manual/en/book.curl.php>
 * DOM for parsing pages <http://www.php.net/manual/en/book.dom.php>
 *
 * @author Simon Coggins <simon.coggins@totaralms.com>
 *
 * @todo:
 * - Allow generalise to visit each type of link N times
 * - Option to display errors as they happen
 * - improve method of obtaining sesskey if possible
 *
 */

if (count($_SERVER['argv']) > 5 || count($_SERVER['argv']) < 2) {
    echo "Syntax:\n";
    echo 'php ' . basename($_SERVER['argv'][0]) . " siteurl [moodle_username] [moodle_password] [startpage]\n\n";
    echo "where:\n";
    echo "siteurl is the full URL with trailing slash  (http://www.my-site.com/)\n";
    echo "moodle_username is the moodle username to login with\n";
    echo "moodle_password is the password for that user (wrap in single quotes if it includes shell characters like '!')\n";
    echo "startpage is the page for the checking to start on\n";
    exit;
}

// URL of site (including trailing slash)
$site_url = $_SERVER['argv'][1];

// moodle login credentials - login as learner by default
$MOODLE_USERNAME = isset($_SERVER['argv'][2]) ? $_SERVER['argv'][2] : 'defaultusername'; // change this
$MOODLE_PASSWORD = isset($_SERVER['argv'][3]) ? $_SERVER['argv'][3] : 'defaultpassword'; // change this

// page to start from (default index.php)
$start_page = isset($_SERVER['argv'][4]) ? $_SERVER['argv'][4] : 'index.php';

// debugging level:
// 0 = no output at all
// 1 = errors only
// 2 = as above, plus some general stats
// 3 = as above, plus basic progress information
// 4 = as above, plus additional progress information
// 5 = full debug messages
$DEBUG_LEVEL = 4;

// if set to true, will visit URLs that contain the user's session key
// enabling this option will likely result in permanent changes to your site,
// and will take longer, but will be a more thorough so may catch more issues
//
// Note: Enabling this option can sometime give false positives, since links
// can be saved to locations that are subsequently deleted by following another
// link before they get visited
$INCLUDE_SESSKEY_URLS = false;

// create a new link checker
$lc = new link_checker($site_url, $start_page);

// mark exceptions
// 2nd argument details which errors to ignore (defaults to 'all')
// Options are:
// 'all': ignore all errors (don't even visit the page)
// 'lang': ignore bad language strings in this page
// 'errorbox': ignore moodle error boxes (as generated by print_error)
// 'sql': ignore moodle SQL error notifications
// 'php': ignore PHP Xdebug warnings/errors/notices
// 'status': ignore bad status codes like 404s
// 'emptylink': ignore links with no content (e.g. <a href=""> )
// 'localip': ignore links to local IP addresses (e.g. <a href="192.168.N.N/anything"> )
// You can ignore multiple errors by providing a comma-separated list

// avoid logging out
$lc->add_to_whitelist('login/logout.php');
// contains an example URL fragment: 'http://'
$lc->add_to_whitelist('help.php?module=wiki&file=howtowiki.html');
// exports in ical format, which breaks urls in the middle
$lc->add_to_whitelist('calendar/export_execute.php');
// fails on local IP lookup
$lc->add_to_whitelist('iplookup/index.php');
// not useful to test
$lc->add_to_whitelist('admin/tool/xmldb/');

// start spidering site
$lc->go();


////////////////////////////////////////////////////////////////
// class definitions
////////////////////////////////////////////////////////////////


/**
 * Class defining a link checker
 */
class link_checker {
    private $site_url, $start_page, $cookie_file;
    private $visited_urls, $urls_to_visit, $errors, $whitelists;

    /**
     * Initialise a new link checker object
     */
    function __construct($site_url, $start_page) {
        $this->site_url = $site_url;
        $this->start_page = $start_page;
        $this->whitelists = array();
        $this->visited_urls = array();
        $this->urls_to_visit = array();
        $this->errors = array();

        // login to site to set session cookies
        // initialization should fail if this doesn't work
        if (!$this->moodle_login($site_url)) {
            throw new Exception('Could not login to moodle - aborting');
        }
        $this->debug('Logged in.', 4);
    }

    /**
     * Print a debug message
     */
    public function debug($message, $level = 1) {
        global $DEBUG_LEVEL;
        if ($DEBUG_LEVEL >= $level) {
            print $message . "\n";
        }
    }

    /**
     * Login to moodle site in order to set required cookies
     */
    private function moodle_login() {
        global $MOODLE_USERNAME, $MOODLE_PASSWORD;

        $this->debug('Logging in to moodle...', 4);

        // create a temp file for storing login cookie
        $this->cookie_file = tempnam(sys_get_temp_dir(), 'cookie');

        // visit login page to get session cookies
        $ch = curl_init();
        $options = array(
            CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; `rv:1.9.2) Gecko/20100115 Firefox/3.6',
            CURLOPT_RETURNTRANSFER => TRUE,
            CURLOPT_COOKIEJAR => $this->cookie_file,
            CURLOPT_FOLLOWLOCATION => 1,
            CURLOPT_URL => $this->site_url . 'login/index.php'
        );
        curl_setopt_array($ch, $options);
        $result = curl_exec($ch);
        if ($result === false) {
            $this->debug(curl_error($ch));
            return false;
        }

        // now POST the login form to set login cookies
        $options[CURLOPT_POST] = TRUE;
        $options[CURLOPT_POSTFIELDS] = array('username' => $MOODLE_USERNAME, 'password' => $MOODLE_PASSWORD, 'testcookies' => 1);
        curl_setopt_array($ch, $options);
        $result = curl_exec($ch);
        if ($result === false) {
            $this->debug(curl_error($ch));
            return false;
        }

        // make sure login was successful
        if (preg_match('/Invalid login, please try again/', $result)) {
            $this->debug('Login failed - bad username or password?', 1);
            return false;
        }

        // closing curl session will write cookie info to temp file
        curl_close($ch);
        unset($ch);

        return true;
    }

    /**
     * Download and parse a specified URL
     *
     * @param   object A 'lc_page' object containing details of a page to be analysed
     * @return  array   HTML data
     */
    private function parse_page(&$page_to_check) {
        if (empty($this->cookie_file)) {
            $this->debug('Could not find cookie, run moodle_login() first!');
            return false;
        }

        // use curl to get the page contents
        $ch = curl_init();
        $options = array(
            CURLOPT_USERAGENT => 'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; `rv:1.9.2) Gecko/20100115 Firefox/3.6',
            CURLOPT_RETURNTRANSFER => TRUE,
            CURLOPT_COOKIEJAR => $this->cookie_file,
            CURLOPT_COOKIEFILE => $this->cookie_file,
            CURLOPT_FOLLOWLOCATION => 1,
            CURLOPT_URL => $page_to_check->actual_url
        );
        curl_setopt_array($ch, $options);
        $result = curl_exec($ch);
        if ($result === false) {
            $this->debug(curl_error($ch));
            return false;
        }
        $statuscode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

        // add the status code to the page object
        $page_to_check->statuscode = $statuscode;

        curl_close($ch);

        // now parse the page contents
        $html = new DOMDocument();
        $html->strictErrorChecking = false;
        $html->substituteEntities = false;
        @$html->loadHTML($result); // hide HTML parse errors
        return array('dom' => $html, 'raw' => $result);
    }

    /**
     * Look for errors in a page's parsed DOM tree
     *
     * Add to this method to include additional checks
     *
     * When an error is found, a new lc_page_error object is created and pushed onto the errors array
     *
     * @param object A parsed version of the page, as generated by parse_page()
     * @param object A 'lc_page' object containing details of a page to be analysed
     */
    private function look_for_errors($parsed_page, $page_to_check) {

        $xpath = new DomXPath($parsed_page['dom']);

        // check for the CSS for 'moodle' error boxes and save a message
        // containing the contents
        $errorbox = false;
        foreach ($xpath->query('//*[contains(@class, \'errorbox\')]') as $message) {
            $errorbox = true;
            if (!$this->is_in_whitelist($page_to_check->actual_url, 'errorbox')) {
                // in Moodle, error details are stored in divs that sit outside of
                // the error box - need to traverse DOM and parse to get actual errors
                $msgdetails = '';
                $first_sibling = $parsed_page['dom']->saveXML($message->nextSibling);
                $second_sibling = $message->nextSibling->nextSibling->nodeValue;

                // make sure the first sibling does contain an error
                if (strstr($first_sibling, 'notifytiny') !== false &&
                    strstr($first_sibling, 'Debug info') !== false) {
                    $msgdetails .= strip_tags(str_replace(array('<br>', '<br />'), array("\n", "\n"), $first_sibling)) . "\n";
                }
                // make sure the second sibling does contain an error
                if (strstr($second_sibling, 'Stack trace') !== false) {
                    $msgdetails .= "             " . $message->nextSibling->nextSibling->nodeValue;
                }
                if (strlen($msgdetails) > 0) {
                    $msgdetails = "\nDetails:     {$msgdetails}";
                }
                $error = new lc_page_error('Error message "' . $message->firstChild->nodeValue . $msgdetails,
                    $page_to_check);
                array_push($this->errors, $error);
            }
        }

        // only include bad status code if it's not on a page generated by error() or print_error()
        // as they will also return a 404 status
        $statuscode = $page_to_check->statuscode;
        if (!$errorbox && $statuscode >= 400) {
            if (!$this->is_in_whitelist($page_to_check->actual_url, 'status')) {
                $error = new lc_page_error('Bad status code reported', $page_to_check);
                array_push($this->errors, $error);
            }
        }

        // look for SQL errors printed to the page
        // this only works if debugging is set high and errors output to page
        // alternatively, just save errors directly to the server logs
        if (!$this->is_in_whitelist($page_to_check->actual_url, 'sql')) {
            foreach ($xpath->query('//div[@class=\'notifytiny\']') as $el) {
                if (preg_match('/call to debugging\(\)/', $el->nodeValue)) {
                    // don't match bad strings, handled later
                    if (!preg_match('/Invalid get_string\(\) identifier/', $el->nodeValue)) {
                        $error = new lc_page_error('SQL Error: "' . $el->nodeValue. '"',
                            $page_to_check);
                        array_push($this->errors, $error);
                    }
                }
            }
        }

        // look for PHP errors
        // this only works if you have debugging set high, errors output to page
        // and Xdebug with pretty error messages installed
        // alternatively, just save errors directly to the server logs
        if (!$this->is_in_whitelist($page_to_check->actual_url, 'php')) {
            // find first <th> tag in the first <tr> tag in every
            // table.xdebug-error table
            foreach ($xpath->query('//table[@class=\'xdebug-error\']/tr[1]/th[1]') as $el) {
                $error = new lc_page_error('PHP Error: "' . $el->nodeValue . '"',
                    $page_to_check);
                array_push($this->errors, $error);
            }
        }

        // get the whole page (unparsed)
        $rawhtml = $parsed_page['raw'];

        // @todo only list each lang string once
        if (!$this->is_in_whitelist($page_to_check->actual_url, 'lang')) {
            $regexp = "/Invalid get_string\(\) identifier: \'([^']*)\' or component \'([^']*)\'\./i";
            if (preg_match_all($regexp, $rawhtml , $matches)) {
                $badstrings = $matches[1];
                $badcomponents = $matches[2];
                foreach ($badstrings as $key => $badstring) {
                    $error = new lc_page_error('Bad language string "' . $badstring . '" in component "' . $badcomponents[$key] . '"',
                        $page_to_check);
                    array_push($this->errors, $error);
                }
            }
        }
    }


    /**
     * Process a parsed HTML page, saving any links to visit
     */
    private function process_links($parsed_page, $page_to_check) {
        global $INCLUDE_SESSKEY_URLS, $USER_SESSKEY;
        $url_to_process = $page_to_check->actual_url;

        // loop through every link in the page
        $xpath = new DomXPath($parsed_page);
        foreach ($xpath->query('//a[@href]') as $link) {
            $url = html_entity_decode(trim($link->getAttribute('href')));

            // log empty urls
            if (strlen($url) == 0 && !$this->is_in_whitelist($page_to_check->actual_url, 'emptylink')) {
                $error = new lc_page_error('Empty URL found in link named "'. $link->nodeValue . '"', $page_to_check);
                array_push($this->errors, $error);
                continue;
            }

            // log local IP addresses
            if ((preg_match('/[^=]192\.168\.[0-9]+\.[0-9]+/', $url) ||
                preg_match('/[^=]172\.[0-9]+\.[0-9]+\.[0-9]+/', $url) ||
                preg_match('/[^=]127\.[0-9]+\.[0-9]+\.[0-9]+/', $url) ||
                preg_match('/[^=]10\.[0-9]+\.[0-9]+\.[0-9]+/', $url))
                && !$this->is_in_whitelist($page_to_check->actual_url, 'localip')) {
                $error = new lc_page_error('Local IP address found in URL "' . $url . '"', $page_to_check);
                array_push($this->errors, $error);
                continue;
            }

            if (preg_match('/^#/', $url)) {
                $this->debug('Skipping anchor link: ' . $url, 5);
                continue;
            }

            // if not yet set, see if this url contains the users
            // sesskey, and if so save it
            if (!isset($USER_SESSKEY)) {
                find_user_sesskey($url);
            }

            // unless we want to include them, skip any link which includes the sesskey
            if (!$INCLUDE_SESSKEY_URLS) {
                if (url_includes_sesskey($url)) {
                    $this->debug('Skipping link that uses the sesskey: ' . $url, 5);
                    continue;
                }
            }

            // add root to relative paths
            $url = rel2abs($url, $url_to_process);

            if (substr($url, 0, strlen($this->site_url)) != $this->site_url) {
                $this->debug('Skipping external link: ' . $url, 5);
                continue;
            }

            // skip urls that match the start of the ignore list (will work for directories)
            if ($this->is_in_whitelist($url, 'all')) {
                $this->debug('Skipping link from ignore list: ' . $url, 5);
                continue;
            }

            // this link has already been visited
            foreach ($this->visited_urls as $visited_url) {
                if (generalise($url) == $visited_url) {
                    $this->debug('Skipping link from visited list: ' . $url . ' as it generalises to match ' . $visited_url, 5);
                    continue 2;
                }
            }

            // already in the list to visit
            foreach ($this->urls_to_visit as $url_to_visit) {
                if ($url_to_visit->generalised_url == generalise($url)) {
                    $this->debug('Skipping link already marked for visiting: '. $url . ' as it generalises to match ' . $url_to_visit->generalised_url, 5);
                    continue 2;
                }

            }

            // nothing wrong with this link
            // add it to the list of links to visit
            $this->debug('Saving link to visit later: ' . $url, 4);
            $item = new lc_page($url, $url_to_process);

            array_push($this->urls_to_visit, $item);

        }

    }

    /**
     * Check links in a specific page and record the results
     *
     * @param object A 'page' object containing details of a page to be analysed
     */
    private function check_page($page_to_check) {

        // add this url to the list of visited pages
        // do it before the check in case it links to itself
        array_push($this->visited_urls, $page_to_check->generalised_url);

        // download the page
        if ($html = $this->parse_page($page_to_check)) {
            // scan the page for any errors
            $this->look_for_errors($html, $page_to_check);
            // parse the links on the page for more pages
            $this->process_links($html['dom'], $page_to_check);
        }
    }


    /**
     * Adds the specified URL to the whitelist (list of URLs not to
     * check for errors
     *
     * By default it adds it to the 'all' whitelist, which means the
     * URL will not even be visited. If a named whitelist is specified
     * (or a comma separated list of names), then it will be added to
     * those specific whitelists, which are only checked for certain errors
     *
     * @param string $url URL to check for whitelisting (without site URL)
     * @param string $typestr Type(s) of whitelisting, default 'all' (optional)
     */
    public function add_to_whitelist($url, $typestr = 'all') {
        // convert $typestr to array
        if (strpos($typestr, ',') !== false) {
            $types = explode(',', $typestr);
        } else {
            $types = array($typestr);
        }

        foreach ($types as $type) {
            // remove whitespace
            $type = trim($type);
            if (strlen($type) === 0) {
                continue;
            }

            if (array_key_exists($type, $this->whitelists)) {
                // append to array
                $this->whitelists[$type][] = $this->site_url . $url;
            } else {
                // create new array
                $this->whitelists[$type] = array($this->site_url . $url);
            }
        }

    }


    /**
     * Returns true if the specified URL is whitelisted (and therefore
     * shouldn't be checked for errors
     *
     * By default it checks if it is whitelisted for all checks, if a
     * second argument is specified it only checks against the named
     * whitelist
     *
     * @param string $url URL to check for whitelisting
     * @param string $type Type of whitelisting, default 'all' (optional)
     * @return boolean True if the $url is whitelisted
     */
    public function is_in_whitelist($url, $type = 'all') {
        if (!array_key_exists($type, $this->whitelists)) {
            // no whitelist by that name
            return false;
        }

        foreach ($this->whitelists[$type] as $item_to_ignore) {
            if (substr($url, 0, strlen($item_to_ignore)) == $item_to_ignore) {
                return true;
            }
        }

    }


    /**
     * Execute the link checker
     *
     * @param string $url URL to start from. Defaults to site start page (optional)
     */
    public function go($url = null) {

        $this->debug('Starting link check...', 2);

        // default to start page
        if (empty($url)) {
            $url = $this->site_url . $this->start_page;
        }

        // make an object containing the URL info
        $item = new lc_page($url);

        // check the initial page
        $this->check_page($item);

        // now work through urls_to_visit until empty
        while (count($this->urls_to_visit) > 0) {
            $page_to_check = array_shift($this->urls_to_visit);
            $actual_url = $page_to_check->actual_url;

            $this->debug(count($this->visited_urls) . ' URLs visited, ' . count($this->urls_to_visit) . ' URLs left to go.' . "\n", 3);
            $this->debug('Visiting URL: '. $actual_url . "\n", 4);
            $this->check_page($page_to_check);

        }

        // print results
        $this->debug("\n" . 'Visited ' . count($this->visited_urls) . ' URLs.' . "\n", 2);

        // report on completion
        if (count($this->errors) == 0) {
            $this->debug('Scan complete. No issues found.', 1);
        } else {
            // print errors
            $err_message = count($this->errors) . " errors found:\n\n";
            foreach ($this->errors as $error) {
                $err_message .= $error->format_error();
            }
            $this->debug($err_message, 1);
        }
    }

} // end of link_checker class


/**
 * Class defining an object containing page error information
 */
class lc_page_error {
    private $message, $page;

    // save the error message and page context
    function __construct($message, $page) {
        $this->message = $message;
        $this->page = $page;
    }

    /**
     * Display the error stored by this object
     */
    public function format_error() {
        $source = empty($this->page->actual_url) ? 'Unknown' : $this->page->actual_url;
        $referrer = empty($this->page->referrer) ? 'None' : $this->page->referrer;
        $statuscode = $this->page->statuscode;

        $out = 'ERROR:       ' . $this->message . "\n";
        $out .= 'Page:        ' . $source . "\n";
        $out .= 'Referrer:    ' . $referrer . "\n";
        // only include status if an error
        if ($statuscode >= 400) {
            $out .= 'HTTP Status: ' . $statuscode . "\n";
        }
        $out .= "\n";

        return $out;
    }

} // end of lc_page_error class

/**
 * Class defining a page object
 * containing information needed when checking a URL
 */
class lc_page {
    public $actual_url, $referrer, $generalised_url;
    public $statuscode;

    function __construct($url, $referrer = null) {
        $this->actual_url = $url;
        $this->referrer = $referrer;
        $this->generalised_url = generalise($url);
        $this->statuscode = null; // set by curl when page fetched
    }

} // end of lc_page class


////////////////////////////////////////////////////////////////
// utility functions
////////////////////////////////////////////////////////////////


/**
 * Convert a relative link into an absolute one
 *
 * @param string $rel Relative URL
 * @param string $base Base URL to use to convert $rel to absolute path
 *
 * @return string Absolute URL for $rel
 */
function rel2abs($rel, $base) {
    // return if already absolute URL
    if (parse_url($rel, PHP_URL_SCHEME) != '') {
        return $rel;
    }

    // queries and anchors
    if ($rel[0]=='#' || $rel[0]=='?') {
        return $base.$rel;
    }

    // parse base URL and convert to local variables:
    //  $scheme, $host, $path
    extract(parse_url($base));

    // remove non-directory element from path
    $path = preg_replace('#/[^/]*$#', '', $path);

    // destroy path if relative url points to root
    if ($rel[0] == '/') {
        $path = '';
    }

    // dirty absolute URL
    $abs = "$host$path/$rel";

    // replace '//' or '/./' or '/foo/../' with '/'
    $re = array('#(/\.?/)#', '#/(?!\.\.)[^/]+/\.\./#');
    for($n=1; $n>0; $abs=preg_replace($re, '/', $abs, -1, $n)) {}

    // absolute URL is ready
    return $scheme.'://'.$abs;
}

/**
 * Convert a URL into a version without any unique parameters
 *
 * @param string $url URL to be generalised
 *
 * @todo convert to use http_build_url() ?
 */
function generalise($url) {
    $pos = strpos($url, '?');
    if ($pos === false ) {
        // no query string to generalise return everything except # fragment
        if ($hashpos = strpos($url, '#')) {
            return substr($url, 0, $hashpos);
        } else {
            return $url;
        }
    }

    // params to always generalise (even when value is a string)
    $always_generalise = array(
        // Some reports have a alphabet bar for filtering usernames, can get into massive loops
        'silast',
        'sifirst',
        // too many pages to check here
        'capability'
    );

    // split query params into an array
    $query = parse_url($url, PHP_URL_QUERY);
    $query_parts = array();
    parse_str($query, $query_parts);

    $new_query_parts = array();
    foreach ($query_parts as $key => $value) {
        if (strlen($value) == 0) {
            continue;
        }
        if (preg_match('/^-?[0-9]+$/', $value)) {
            // convert integers
            $new_query_parts[] = $key . '=X';
        } else if (in_array($key, $always_generalise)) {
            // convert sort parameters
            $new_query_parts[] = $key . '=X';
        } else {
            $new_query_parts[] = $key . '=' . $value;
        }
    }
    // sort array so id=X&course=Y matches course=Y&id=X
    asort($new_query_parts);

    // re-build the URL with new parameters (excluding any
    // # fragment)
    return substr($url, 0, $pos + 1) . implode('&', $new_query_parts);
}

/**
 * Does a specific url contain the logged in user's sesskey as a parameter?
 *
 * @param string $url URL to check for sesskey
 * @return boolean True if the sesskey is a value in the url, false otherwise
 */
function url_includes_sesskey($url) {
    global $USER_SESSKEY;

    // no way to check if not defined
    if (!isset($USER_SESSKEY)) {
        return false;
    }

    // split query params into an array
    $query = parse_url($url, PHP_URL_QUERY);
    $query_parts = array();
    parse_str($query, $query_parts);

    foreach ($query_parts as $key => $value) {
        if ($value == $USER_SESSKEY) {
            return true;
        }
    }
    return false;
}

/**
 * Find and save the user's sesskey from this url
 *
 * @todo Find a better way to get the user's sesskey than this!
 *
 * @param string $url The url to check
 */
function find_user_sesskey($url) {
    global $USER_SESSKEY;

    // split query params into an array
    $query = parse_url($url, PHP_URL_QUERY);
    $query_parts = array();
    parse_str($query, $query_parts);

    foreach ($query_parts as $key => $value) {
        if ($key == 'sesskey') {
            $USER_SESSKEY = $value;
            break;
        }
    }
}
?>

